var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#LeniaDynamics.AbstractFeedback","page":"API","title":"LeniaDynamics.AbstractFeedback","text":"AbstractFeedback\n\nMarker supertype for optional global feedback controllers that make Lenia dynamics more robust.\n\n\n\n\n\n","category":"type"},{"location":"api/#LeniaDynamics.KernelSpec","page":"API","title":"LeniaDynamics.KernelSpec","text":"KernelSpec(; radius, rings, ring_widths, ring_weights)\n\nRadially symmetric kernel specification for Lenia.\n\nradius::Int: kernel radius in cells\nrings::Vector{Float32}: ring centers (0..1)\nring_widths::Vector{Float32}: ring widths (0..1)\nring_weights::Vector{Float32}: ring weights (not necessarily normalized)\n\nThe resulting kernel is normalized to sum to 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#LeniaDynamics.LeniaParams","page":"API","title":"LeniaDynamics.LeniaParams","text":"LeniaParams(; kernel, growth, μ, σ, dt)\n\nLenia parameters:\n\nkernel::KernelSpec\ngrowth::Function: growth mapping G(u) -> Δa in [-1, 1] (typically)\nμ, σ: growth parameters (used by default growth functions)\ndt: time step\n\n\n\n\n\n","category":"type"},{"location":"api/#LeniaDynamics.LeniaState","page":"API","title":"LeniaDynamics.LeniaState","text":"LeniaState(A; backend=:fft)\n\nSimulation state containing the grid A and backend-specific caches.\n\n\n\n\n\n","category":"type"},{"location":"api/#LeniaDynamics.MassFeedback","page":"API","title":"LeniaDynamics.MassFeedback","text":"MassFeedback(; ρ=0.12f0, κ=0.5f0, mode=:additive, period=1, clamp_scale=(0.5f0, 2.0f0))\n\nA simple global homeostasis controller that prevents \"everything dies\" (extinction) and reduces runaway saturation.\n\nThe controller measures the current mean density m = mean(A) and nudges the state toward a target ρ.\n\nmode=:additive: A ← clamp(A + dt * κ*(ρ - m), 0, 1)\nmode=:rescale : A ← clamp(A * s, 0, 1) where s = clamp(ρ/max(m,eps), clamp_scale...)\n\nperiod applies the control only every period steps (useful to reduce overhead on GPU).\n\nThis is not part’s of \"classic\" Lenia, but is extremely useful for interactive exploration and educational demos because it makes simulations far less fragile.\n\n\n\n\n\n","category":"type"},{"location":"api/#LeniaDynamics._convolve_fft!-Tuple{AbstractMatrix{Float32}, LeniaState{Float32, AT} where AT<:AbstractMatrix{Float32}, AbstractMatrix{Float32}}","page":"API","title":"LeniaDynamics._convolve_fft!","text":"_convolve_fft!(U, st, A)\n\nBackward-compatible helper that uses st.cache[:params] as LeniaParams. This is not the preferred API (use the 4-arg method), but it can be convenient for exploratory REPL usage.\n\nThrows ArgumentError if :params is not present in st.cache.\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics._convolve_fft!-Tuple{AbstractMatrix{Float32}, LeniaState{Float32, AT} where AT<:AbstractMatrix{Float32}, LeniaParams, AbstractMatrix{Float32}}","page":"API","title":"LeniaDynamics._convolve_fft!","text":"_convolve_fft!(U, st, p, A)\n\nCompute U = K * A using circular convolution via FFT (CPU). All arrays are Float32 matrices; internal buffers are ComplexF32.\n\nThis is allocation-free once cache is prepared.\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics._convolve_naive!-Tuple{AbstractMatrix{Float32}, AbstractMatrix{Float32}, AbstractMatrix{Float32}, Int64}","page":"API","title":"LeniaDynamics._convolve_naive!","text":"_convolve_naive!(U, A, Ksmall; radius)\n\nCompute U = K * A using direct summation with periodic boundaries. O(N^2 * r^2): intended mainly for validation / small kernels.\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics._make_small_kernel-Tuple{KernelSpec}","page":"API","title":"LeniaDynamics._make_small_kernel","text":"_make_small_kernel(spec::KernelSpec) -> Ksmall\n\nConstruct a small (2r+1)x(2r+1) kernel for naive convolution.\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics._prepare_fft_cache!-Tuple{LeniaState{Float32, AT} where AT<:AbstractMatrix{Float32}, LeniaParams}","page":"API","title":"LeniaDynamics._prepare_fft_cache!","text":"_prepare_fft_cache!(st, p)\n\nCreate or update FFT caches in st.cache for current grid size and kernel spec.\n\nCaches:\n\n:N          : grid size\n:kernel_spec: last kernel spec used\n:plan_f     : forward FFT plan (out-of-place)\n:plan_b     : inverse FFT plan (out-of-place, normalized like ifft)\n:K̂         : kernel spectrum (ComplexF32)\n:Ac         : complex buffer for input (A)\n:Â         : complex buffer for spectrum(A)\n:Uc         : complex buffer for inverse FFT result\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics.apply_feedback!-Tuple{LeniaState{Float32, AT} where AT<:AbstractMatrix{Float32}, AbstractFeedback}","page":"API","title":"LeniaDynamics.apply_feedback!","text":"apply_feedback!(st, fb; dt=st.cache[:params].dt)\n\nApply a feedback controller fb to the state st.\n\nCurrently implemented controllers:\n\nMassFeedback\n\nThe controller is applied in-place and is compatible with CPU arrays and (when CUDA.jl is present) CuArrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics.auto_calibrate!-Tuple{LeniaState{Float32, AT} where AT<:AbstractMatrix{Float32}, LeniaParams}","page":"API","title":"LeniaDynamics.auto_calibrate!","text":"auto_calibrate!(st, p; target=p.μ, statistic=:meanU, clamp_scale=(0.25f0, 4f0))\n\nMake initialization much less fragile by scaling the initial state so that the kernel response U = K*A is near the growth center μ.\n\nThis is a practical robustness trick for interactive exploration:\n\ncompute U = K*A\ncompute s = target / statistic(U)\nset A ← clamp(A*s, 0, 1)\n\nstatistic=:meanU uses mean(U) (recommended). You can also use :medianU for more robustness.\n\nReturns (scale=s, value=v) where v is the measured statistic of U before scaling.\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics.bump_growth-Tuple{Real, Real, Real}","page":"API","title":"LeniaDynamics.bump_growth","text":"bump_growth(u, μ, σ) -> g\n\nSmooth bump-like growth (steeper shoulders).\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics.gaussian_growth-Tuple{Real, Real, Real}","page":"API","title":"LeniaDynamics.gaussian_growth","text":"gaussian_growth(u, μ, σ) -> g\n\nSmooth growth function often used in Lenia-like systems: g = 2 * exp(-((u-μ)^2)/(2σ^2)) - 1\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics.initialize_state-Tuple{Integer}","page":"API","title":"LeniaDynamics.initialize_state","text":"initialize_state(N; init=:noise, seed=1, backend=:fft, kwargs...) -> LeniaState\n\nCreate an N×N state.\n\nBuilt-in initializers:\n\ninit=:noise     – uniform noise in [0, noise_amp] (default noise_amp=0.1)\ninit=:spot      – centered Gaussian blob + small noise\ninit=:sprinkle  – many small Gaussian blobs randomly placed (good for \"many small organisms\" regimes)\ninit=:primordia – alias for :sprinkle with parameters tuned for fragmented dynamics\n\nKeywords:\n\nnoise_amp::Float32=0.1f0\nspot_sigma_frac::Float32=0.12f0  (sigma = spot_sigma_frac*N)\nspot_amp::Float32=0.8f0\nsprinkle_n::Int (default scales with N)\nsprinkle_sigma::Float32=2.0f0\nsprinkle_amp::Float32=0.8f0\nsprinkle_radius::Int=6 (cutoff radius for blob stamping)\n\nNotes:\n\nbackend is stored in the returned state; you can later call to_device(st, :cuda) when CUDA is available.\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics.integrate_step!-Tuple{LeniaState{Float32, AT} where AT<:AbstractMatrix{Float32}, LeniaParams, Euler}","page":"API","title":"LeniaDynamics.integrate_step!","text":"integrate_step!(st, p, integrator)\n\nAdvance state by one step using the chosen integrator. Clamps A into [0,1] after the step.\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics.make_preset-Tuple{Symbol}","page":"API","title":"LeniaDynamics.make_preset","text":"make_preset(name; N=256, seed=1, backend=:fft)\n\nConvenience: create (st, p, integrator) from a preset.\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics.preset-Tuple{Symbol}","page":"API","title":"LeniaDynamics.preset","text":"preset(name::Symbol; N=256)\n\nReturn a named preset as a NamedTuple with fields:\n\nkernel::KernelSpec\ngrowth (a scalar growth function, broadcastable)\nμ::Float32, σ::Float32, dt::Float32\nintegrator::Integrator (Euler/RK2/RK4)\ninit::Symbol and init_kwargs::NamedTuple for initialize_state\nfeedback::Union{Nothing,AbstractFeedback} (optional global homeostasis)\nautocalibrate::Bool (scale init so mean(K*A) ≈ μ)\n\nPresets are intended as practical starting points for exploration and GUI defaults.\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics.rhs!-Tuple{AbstractMatrix{Float32}, LeniaState{Float32, AT} where AT<:AbstractMatrix{Float32}, LeniaParams, AbstractMatrix{Float32}}","page":"API","title":"LeniaDynamics.rhs!","text":"rhs!(dA, st, p, A)\n\nCompute the right-hand side dA .= G(K*A; μ, σ) into dA.\n\nA may be a CPU array (Matrix) or GPU array (CuArray) depending on backend.\ndA must be allocated on the same device/type as A.\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics.run!-Tuple{LeniaState{Float32, AT} where AT<:AbstractMatrix{Float32}, LeniaParams, Integer}","page":"API","title":"LeniaDynamics.run!","text":"run!(st, p, steps; callback=nothing)\n\nRun steps iterations. If callback is provided, it is called as callback(step, st).\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics.set_fftw_threads!-Tuple{Integer}","page":"API","title":"LeniaDynamics.set_fftw_threads!","text":"set_fftw_threads!(n)\n\nSet FFTW thread count (affects FFT backend on CPU).\n\n\n\n\n\n","category":"method"},{"location":"api/#LeniaDynamics.step!-Tuple{LeniaState{Float32, AT} where AT<:AbstractMatrix{Float32}, LeniaParams}","page":"API","title":"LeniaDynamics.step!","text":"step!(st, p; method=:auto) -> st\n\nAdvance the state by one step using the selected backend:\n\n:fft – CPU FFT convolution (fast)\n:naive – CPU direct convolution (threaded; validation)\n:cuda – optional CUDA convolution (requires CUDA.jl; see cuda_optional.jl)\n\n\n\n\n\n","category":"method"},{"location":"performance/#Performance","page":"Performance","title":"Performance","text":"Lenia spends most time in the convolution step (computing U = K ∗ A). LeniaDynamics provides multiple implementations so you can trade off correctness checks, speed, and hardware.","category":"section"},{"location":"performance/#Backends-in-practice","page":"Performance","title":"Backends in practice","text":":fft (CPU, FFTW): best for medium/large grids (typical Lenia sizes 128–1024).\n:naive (CPU): simple direct convolution; useful for debugging and small kernels.\n:cuda (GPU): optional; requires CUDA.jl and a functional CUDA installation.","category":"section"},{"location":"performance/#Benchmark-script","page":"Performance","title":"Benchmark script","text":"The repository includes a reproducible benchmark script:\n\njulia --project=scripts scripts/bench.jl\n\nYou can control the grid size and steps via environment variables:\n\n# Linux/macOS\nLENIA_N=512 LENIA_STEPS=50 julia --project=scripts scripts/bench.jl\n\n# Windows (PowerShell)\n$env:LENIA_N=512; $env:LENIA_STEPS=50; julia --project=scripts scripts/bench.jl\n\nThe script reports the time per step for :fft and :naive backends, and :cuda if available.","category":"section"},{"location":"performance/#FFTW-threading","page":"Performance","title":"FFTW threading","text":"FFTW can use multiple CPU threads. LeniaDynamics exposes a small helper:\n\nusing LeniaDynamics\nLeniaDynamics.set_fftw_threads!(Threads.nthreads())\n\nA good practice is to benchmark several thread counts (e.g. 1, 2, 4, …) for your target grid size.","category":"section"},{"location":"performance/#Practical-tuning-tips","page":"Performance","title":"Practical tuning tips","text":"Use :fft for most real runs.\nFor correctness/regression tests, compare :fft vs :naive on smaller grids.\nKeep A in Float32 (default) for speed.\nAvoid allocating in the step loop; LeniaDynamics caches FFT plans and kernel spectra per state.","category":"section"},{"location":"performance/#CUDA-notes","page":"Performance","title":"CUDA notes","text":"GPU acceleration is optional and enabled via the package extension. Install CUDA.jl:\n\nimport Pkg\nPkg.add(\"CUDA\")\n\nThen select backend=:cuda via initialize_state(...; backend=:cuda) or convert an existing state:\n\nstg = to_device(st, :cuda)\n\nIn the Makie GUI, rendering every k frames can reduce GPU→CPU transfer overhead.","category":"section"},{"location":"#LeniaDynamics.jl","page":"Home","title":"LeniaDynamics.jl","text":"LeniaDynamics.jl is a reusable, performance-oriented Lenia (continuous Game of Life) simulator. It provides CPU FFT convolution, a threaded naive backend for validation, and optional CUDA acceleration.","category":"section"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"using LeniaDynamics\n\nspec = KernelSpec(\n    radius=13,\n    rings=Float32[0.45, 0.75],\n    ring_widths=Float32[0.15, 0.12],\n    ring_weights=Float32[1.0, 0.7],\n)\n\np = LeniaParams(kernel=spec, μ=0.15f0, σ=0.015f0, dt=0.10f0)\n\nst = initialize_state(256; init=:spot, seed=42, backend=:fft)\nrun!(st, p, 200; integrator=RK2())","category":"section"},{"location":"#Where-to-start","page":"Home","title":"Where to start","text":"Read Tutorial for the mapping from Conway → Lenia and a minimal example.\nRead Performance for benchmarking, backend selection, and tuning tips.","category":"section"},{"location":"#GUI-/-visualization","page":"Home","title":"GUI / visualization","text":"The interactive GUI is in scripts/run_gui.jl. Run it from the package root:\n\njulia --project=scripts scripts/run_gui.jl","category":"section"},{"location":"#Presets","page":"Home","title":"Presets","text":"st, p, integ = make_preset(:primordia; N=256, seed=42, backend=:fft)\nrun!(st, p, 500; integrator=integ)","category":"section"},{"location":"tutorial/#Tutorial:-Conway-Lenia","page":"Tutorial","title":"Tutorial: Conway → Lenia","text":"Conway's Game of Life evolves a binary grid with a local, discrete rule. Lenia replaces this with a continuous field and a smooth, non-local update.\n\nThis page explains the mapping and shows how to run LeniaDynamics.jl.","category":"section"},{"location":"tutorial/#1.-State:-from-bits-to-a-continuous-field","page":"Tutorial","title":"1. State: from bits to a continuous field","text":"Conway: cell state is 0/1.\nLenia: the state is a real-valued field A(x, y) ∈ [0, 1].\n\nIn LeniaDynamics.jl this field lives in st.A.","category":"section"},{"location":"tutorial/#2.-Neighborhood:-from-integer-counts-to-convolution","page":"Tutorial","title":"2. Neighborhood: from integer counts to convolution","text":"In Conway you count the alive neighbors in a 3×3 neighborhood. In Lenia you compute a potential field U by convolving the current state A with a kernel K:\n\nU = K ∗ A\n\nLeniaDynamics supports multiple backends:\n\nbackend=:fft uses FFT-based circular convolution (fast for medium/large grids)\nbackend=:naive uses direct convolution (threaded; useful for validation and tiny kernels)\nbackend=:cuda is optional if CUDA.jl is installed","category":"section"},{"location":"tutorial/#3.-Growth:-smooth-birth/death-instead-of-thresholds","page":"Tutorial","title":"3. Growth: smooth birth/death instead of thresholds","text":"Conway uses integer thresholds (under/overpopulation). Lenia uses a smooth growth function g(U; μ, σ) that returns values roughly in [-1, 1]. A common choice is a Gaussian-shaped growth centered at μ with width σ.\n\nThe field is then updated by integrating\n\ndA/dt = g(U)\n\nand clamping back to [0, 1].","category":"section"},{"location":"tutorial/#4.-Time-integration","page":"Tutorial","title":"4. Time integration","text":"Lenia is often presented with explicit Euler integration:\n\nAₙ₊₁ = clamp(Aₙ + dt * g(Uₙ), 0, 1)\n\nLeniaDynamics also includes explicit RK2/RK4 (useful for stability experiments).","category":"section"},{"location":"tutorial/#5.-Minimal-working-example","page":"Tutorial","title":"5. Minimal working example","text":"using LeniaDynamics\n\n# Kernel: a weighted mixture of rings (\"donut\" bands)\nspec = KernelSpec(\n    radius=13,\n    rings=Float32[0.45, 0.75],\n    ring_widths=Float32[0.15, 0.12],\n    ring_weights=Float32[1.0, 0.7],\n)\n\np = LeniaParams(\n    kernel=spec,\n    growth=gaussian_growth,\n    μ=0.15f0,\n    σ=0.015f0,\n    dt=0.10f0,\n)\n\nst = initialize_state(256; init=:spot, seed=42, backend=:fft)\nrun!(st, p, 200; integrator=RK2())\n\n# Result is in st.A (Matrix{Float32} on CPU backends)","category":"section"},{"location":"tutorial/#6.-Presets-(recommended-for-demos)","page":"Tutorial","title":"6. Presets (recommended for demos)","text":"The package ships with presets tuned for stability and long runs:\n\nst, p, integ = make_preset(:primordia; N=256, seed=42, backend=:fft)\nrun!(st, p, 500; integrator=integ)\n\nIf you want a \"stays alive\" demo, try:\n\nst, p, integ = make_preset(:sustain; N=256, seed=1, backend=:fft)\nrun!(st, p, 2000; integrator=integ)","category":"section"},{"location":"tutorial/#7.-Where-to-go-next","page":"Tutorial","title":"7. Where to go next","text":"See the Performance page for benchmarking and backend selection.\nRun scripts/run_gui.jl for an interactive Makie GUI.","category":"section"}]
}
